已经有很多成熟的嵌入式操作系统， 但对于低成本，低功耗的简单应用场景， 这些嵌入式操作系统往往是过于庞大和复杂的。
因此我写了这个简单的基于消息的操作系统， 它对RAM需求很少，并可以减少对栈的深度的需求，支持低功耗使用场景，可以极大的简化程序的耦合，使程序简单易写
最简单的一个消息循环的情况下 最小内存需求为最小200个字节 。
系统基于消息运行, 消息由硬件中断或软件产生，并分发到不同的消息循环
系统的消息可以为一个简单的 消息ID  ， 也可以包含一个内存块 ，支持两种消息 ： 长消息和短消息，  
长消息由 4字节构成， 高2字节为内存块ID， 高两字节为消息ID。 短消息由2字节构成 10位 消息ID 和7位 内存块ID 

系统可以建立多个消息循环，每一个消息循环包含一个消息队列， 系统按照建立消息循环的次序，循环调用每一个消息循环并执行消息队列中的事件。
每一个消息循环可以同时注册多个静态线程， 每一个静态线程将注册并等待多个事件 ，
消息循环优先将事件分发到这些静态线程 ， 如果事件没有被消息循环中的静态线程处理， 则由消息循环本身处理 。
对于基于时间的消息，定义了两种结构
A ：固定的闹钟消息 ，适用于长周期的，循环或非循环时间事件的分发 ，  这些消息静态存储在程序中，系统对这些事件排序并使用RTC逐一触发这些事件，并将其预定义的消息及其参数 分发到消息循环中
B ：短时的定时消息 ，适用于运行中定时事件的分发 ，  这些消息由软件产生，使用一个低功耗定时器对这些事件排序并逐一产生，并将其内包含的消息分发到指定的消息循环





There are many mature embedded operating systems, but for simple application scenarios with low cost and low power consumption, 
these embedded operating systems are often too large and complex.


Therefore, I wrote this simple message based operating system, which has little demand for ram, reduces the demand for the depth of the stack, 
supports low-power use scenarios, greatly simplifies the coupling of programs, and makes the program simple and easy to write .


In the simplest case of one message loop, the minimum memory requirement is a minimum of 200 bytes


the system based on message ,  Each message contains a message ID and a memory block ID, which are generated by the hardware layer interrupt or software and sent to different message loops
The message of the system can be a simple message ID or combined with a memory block. 
It supports two kinds of messages: long message and short message. 
The long message consists of 4 bytes, the high 2 bytes are the memory block ID, and the high 2 bytes are the message ID. 
The short message consists of 2 bytes, 10 bit message ID and 7-bit memory block ID.



The system can establish multiple message loops. Each message loop contains a message queue. 
The system calls each message loop and executes the events in the message queue according to the order of establishing message loops.



Each message loop can register multiple static threads at the same time, and each static thread will register and wait for multiple events,


The message loop gives priority to distributing events to these static threads. If the events are not processed by the static threads in the message loop, 
they are processed by the message loop itself.


For time-based messages, two structures are defined

 
A: Fixed alarm messages are applicable to the distribution of long-period, cyclic or non cyclic time events. These messages are statically stored in the program. 
   The system sorts these events and triggers them one by one using RTC, and distributes their predefined messages and their parameters to the message cycle


B: Short time timing messages are applicable to the distribution of running timing events. These messages are generated by software. 
   A low-power timer is used to sort these events and generate them one by one, and the messages contained in them are distributed to the specified message cycle